<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual PDF Watermark Remover</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    
    <script>
        // Set worker for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>

    <style>
        #canvas-container {
            position: relative;
            display: inline-block;
            border: 2px dashed #ccc;
            overflow: hidden;
            cursor: crosshair;
        }
        canvas {
            display: block;
        }
        /* The red box that appears when you drag */
        #selection-box {
            border: 2px solid red;
            background-color: rgba(255, 0, 0, 0.2);
            position: absolute;
            display: none;
            pointer-events: none; /* Let clicks pass through to canvas */
        }
    </style>
</head>
<body class="bg-slate-100 min-h-screen p-8 font-sans">

    <div class="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-xl">
        <h1 class="text-3xl font-bold mb-2 text-slate-800">Visual Watermark Remover</h1>
        <p class="text-slate-600 mb-6">1. Upload PDF &rarr; 2. Draw a box over the watermark on the preview &rarr; 3. Download.</p>

        <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-100">
            <input type="file" id="pdfInput" accept="application/pdf" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700"/>
        </div>

        <div id="editor-area" class="hidden">
            <h2 class="font-bold text-lg mb-2">Draw a box over the watermark:</h2>
            
            <div id="canvas-container">
                <canvas id="pdf-render"></canvas>
                <div id="selection-box"></div>
            </div>

            <div class="mt-6 flex items-center gap-4">
                <button onclick="processPDF()" class="bg-green-600 text-white px-8 py-3 rounded shadow hover:bg-green-700 font-bold transition">
                    Remove Watermark (Apply to All Pages)
                </button>
                <span id="status" class="text-sm font-semibold text-slate-500"></span>
            </div>
        </div>
    </div>

    <script>
        let pdfDoc = null;       // The loaded pdf-lib document
        let pdfData = null;      // The raw array buffer
        let pdfPageWidth = 0;    // Actual PDF width
        let pdfPageHeight = 0;   // Actual PDF height
        let canvasScale = 1.0;   // Scale factor of the canvas rendering

        // Selection coordinates (screen pixels)
        let rect = { startX: 0, startY: 0, w: 0, h: 0 };
        let isDragging = false;

        const fileInput = document.getElementById('pdfInput');
        const editorArea = document.getElementById('editor-area');
        const canvas = document.getElementById('pdf-render');
        const ctx = canvas.getContext('2d');
        const selectionBox = document.getElementById('selection-box');
        const container = document.getElementById('canvas-container');

        // 1. Handle File Upload
        fileInput.addEventListener('change', async (e) => {
            if (e.target.files.length === 0) return;
            
            const file = e.target.files[0];
            pdfData = await file.arrayBuffer();

            // Render first page with PDF.js
            const loadingTask = pdfjsLib.getDocument({ data: pdfData });
            const pdf = await loadingTask.promise;
            const page = await pdf.getPage(1);

            // Calculate scale to fit width of container (max 800px approx)
            const viewportRaw = page.getViewport({ scale: 1 });
            const desiredWidth = Math.min(800, window.innerWidth - 100);
            canvasScale = desiredWidth / viewportRaw.width;
            
            const viewport = page.getViewport({ scale: canvasScale });

            // Set canvas dimensions
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            // Store actual PDF dimensions for later math
            pdfPageWidth = viewportRaw.width;
            pdfPageHeight = viewportRaw.height;

            // Render
            const renderContext = {
                canvasContext: ctx,
                viewport: viewport
            };
            await page.render(renderContext).promise;
            
            editorArea.classList.remove('hidden');
        });

        // 2. Handle Mouse Drawing (The "Box")
        container.addEventListener('mousedown', (e) => {
            const rectBounds = container.getBoundingClientRect();
            rect.startX = e.clientX - rectBounds.left;
            rect.startY = e.clientY - rectBounds.top;
            isDragging = true;
            
            // Reset box
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';
        });

        container.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rectBounds = container.getBoundingClientRect();
            const currentX = e.clientX - rectBounds.left;
            const currentY = e.clientY - rectBounds.top;

            rect.w = currentX - rect.startX;
            rect.h = currentY - rect.startY;

            // Update visual box
            selectionBox.style.left = (rect.w > 0 ? rect.startX : currentX) + 'px';
            selectionBox.style.top = (rect.h > 0 ? rect.startY : currentY) + 'px';
            selectionBox.style.width = Math.abs(rect.w) + 'px';
            selectionBox.style.height = Math.abs(rect.h) + 'px';
        });

        container.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // 3. Process the PDF (Apply mask to all pages)
        async function processPDF() {
            if (!pdfData) return;
            const status = document.getElementById('status');
            
            // Validate selection
            if (rect.w === 0 || rect.h === 0) {
                alert("Please draw a box over the watermark first!");
                return;
            }

            try {
                status.innerText = "Processing...";

                // Load document into pdf-lib
                const pdfDoc = await PDFLib.PDFDocument.load(pdfData);
                const pages = pdfDoc.getPages();

                // --- COORDINATE MATH ---
                // We must convert "Screen Pixels" (top-left origin) 
                // to "PDF Points" (bottom-left origin).

                // 1. Normalize selection (handle dragging backwards)
                const selX = rect.w > 0 ? rect.startX : rect.startX + rect.w;
                const selY = rect.h > 0 ? rect.startY : rect.startY + rect.h;
                const selW = Math.abs(rect.w);
                const selH = Math.abs(rect.h);

                // 2. Scale back to original PDF size
                const pdfX = selX / canvasScale;
                // PDF Y starts from bottom, so we subtract from height
                // The visual Y (top-down) needs to be converted to bottom-up
                const pdfY_visual = selY / canvasScale; 
                const pdfH = selH / canvasScale;
                const pdfW = selW / canvasScale;

                // Important: In PDF-lib, Y is distance from the BOTTOM.
                // So Y = PageHeight - (VisualY + VisualHeight)
                const finalY = pdfPageHeight - (pdfY_visual + pdfH);

                // Apply to ALL pages
                pages.forEach(page => {
                    page.drawRectangle({
                        x: pdfX,
                        y: finalY,
                        width: pdfW,
                        height: pdfH,
                        color: PDFLib.rgb(1, 1, 1), // White
                        opacity: 1,
                    });
                });

                // Download
                const pdfBytes = await pdfDoc.save();
                download(pdfBytes, "cleaned_file.pdf");
                status.innerText = "Done!";

            } catch (err) {
                console.error(err);
                status.innerText = "Error!";
                alert("Something went wrong. See console.");
            }
        }

        function download(data, filename) {
            const blob = new Blob([data], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    </script>
</body>
</html>
